name = "Provision Tenant"
default_guided_failure_mode = "EnvironmentDefault"
description = "Runbook that will create the necessary infrastructure on the Kubernetes cluster and in the SQL Server needed by the application."
multi_tenancy_mode = "Tenanted"

connectivity_policy {
    allow_deployments_to_no_targets = true
}

run_retention_policy {
    type = "Default"
}

process {
    step "azure-key-vault-retrieve-secrets" {
        name = "Azure Key Vault - Retrieve Secrets"

        action {
            properties = {
                Azure.KeyVault.RetrieveSecrets.Account = "KeyVault.Azure.Account"
                Azure.KeyVault.RetrieveSecrets.PrintVariableNames = "False"
                Azure.KeyVault.RetrieveSecrets.VaultName = "#{KeyVault.Azure.Name}"
                Azure.KeyVault.RetrieveSecrets.VaultSecrets = "#{KeyVault.Azure.Secrets.List}"
                Octopus.Action.Template.Id = "ActionTemplates-561"
                Octopus.Action.Template.Version = "2"
            }
            worker_pool_variable = "Standards.Worker.Pool"
        }
    }

    step "create-database-azure-sql-create-database-if-not-exists" {
        name = "Create Database-SQL - Create Database If Not Exists - Azure or Local"

        action {
            action_type = "Octopus.Script"
            is_required = true
            notes = <<-EOT
                    **Always Runs**
                    
                    Runs a script on a local or Azure Sql Server to ensure the database exists and is configured as a serverless general purpose database with 1 vCore.
                    EOT
            properties = {
                Octopus.Action.AutoRetry.MaximumCount = "3"
                Octopus.Action.AutoRetry.MinimumBackoff = "15"
                Octopus.Action.Blueprint.ConsumingAction.Name = "Create Database"
                Octopus.Action.Script.ScriptBody = <<-EOT
                    $createSQLServer = $OctopusParameters["Template.SQLServer.Name"]
                    $createSqlLoginUserWhoHasCreateUserRights = $OctopusParameters["Template.SQLServer.User.Name"]
                    $createSqlLoginPasswordWhoHasRights = $OctopusParameters["Template.SQLServer.User.Password"]
                    $createDatabaseName = $OctopusParameters["Template.SQLServer.Database.Name"]
                    $createCommandTimeout = 60
                    $createSqlDatabaseRetryAttempts = 3
                    
                    if ([string]::IsNullOrWhiteSpace($createSqlLoginUserWhoHasCreateUserRights) -eq $true) {
                        Write-Output "No username found, using integrated security"
                        $connectionString = "Server=$createSqlServer;Database=master;integrated security=true;"
                    }
                    else {
                        Write-Output "Username found, using SQL Authentication"
                        $connectionString = "Server=$createSqlServer;Database=master;User ID=$createSqlLoginUserWhoHasCreateUserRights;Password=$createSqlLoginPasswordWhoHasRights;"
                    }
                    
                    
                    function Retry-Command {
                        [CmdletBinding()]
                        Param(
                            [Parameter(Position = 0, Mandatory = $true)]
                            [scriptblock]$ScriptBlock,
                     
                            [Parameter(Position = 1, Mandatory = $false)]
                            [int]$Maximum = 1,
                    
                            [Parameter(Position = 2, Mandatory = $false)]
                            [int]$Delay = 100
                        )
                    
                        Begin {
                            $count = 0
                        }
                    
                        Process {
                            $ex = $null
                            do {
                                $count++
                                
                                try {
                                    Write-Verbose "Attempt $count of $Maximum"
                                    $ScriptBlock.Invoke()
                                    return
                                }
                                catch {
                                    $ex = $_
                                    Write-Warning "Error occurred executing command (on attempt $count of $Maximum): $($ex.Exception.Message)"
                                    Start-Sleep -Milliseconds $Delay
                                }
                            } while ($count -lt $Maximum)
                    
                            # Throw an error after $Maximum unsuccessful invocations. Doesn't need
                            # a condition, since the function returns upon successful invocation.
                            throw "Execution failed (after $count attempts): $($ex.Exception.Message)"
                        }
                    }
                    
                    [int]$maximum = 0
                    [int]$delay = 100
                    
                    if (-not [int]::TryParse($createSqlDatabaseRetryAttempts, [ref]$maximum)) { $maximum = 0 }
                    
                    # We add 1 here as if retry attempts is 1, this means we make 2 attempts overall
                    $maximum = $maximum + 1
                    
                    Retry-Command -Maximum $maximum -Delay $delay -ScriptBlock {
                    	
                        $sqlConnection = New-Object System.Data.SqlClient.SqlConnection
                        $sqlConnection.ConnectionString = $connectionString
                        try {
                            
                            $command = $sqlConnection.CreateCommand()
                            $command.CommandType = [System.Data.CommandType]'Text'
                            $command.CommandTimeout = $createCommandTimeout
                    
                            Write-Output "Opening the connection to $createSqlServer"
                            $sqlConnection.Open()
                    
                            $escapedDatabaseName = $createDatabaseName.Replace("'", "''")
                    
                            Write-Output "Running the if not exists then create for $createDatabaseName"
                            $command.CommandText = "IF NOT EXISTS (select Name from sys.databases where Name = '$escapedDatabaseName')
                            create database [$createDatabaseName]"
                            
                            if ($createSqlServer -like '*.database.windows.net')
                            {
                              Write-Host "The SQL Server is an azure sql server, adding Azure SQL Syntax"
                              $createAzureEdition = "GeneralPurpose"        
                              Write-Verbose "Specifying Azure SqlDb Edition: $($createAzureEdition)"
                              $command.CommandText += ("`r`n (EDITION = '{0}'" -f $createAzureEdition)
                            
                              $createAzureServiceObjective = "GP_S_Gen5_1"
                              Write-Verbose "Specifying Azure SqlDb Service Objective to: $($createAzureEdition)"
                              $command.CommandText += (", SERVICE_OBJECTIVE = '{0}')" -f $createAzureServiceObjective)
                            
                    		  $createAzureBackupStorageRedundancy = "LOCAL"
                    		  Write-Verbose "Specifying Azure Backup storage redundancy: $($createAzureBackupStorageRedundancy)"
                              $command.CommandText += ("`r`n WITH BACKUP_STORAGE_REDUNDANCY='{0}'" -f $createAzureBackupStorageRedundancy)
                            }
                            else
                            {
                              Write-Host "The SQL Server appears to be local, skipping the Azure SQL Syntax."
                            }
                    
                            $command.CommandText += ";"
                            Write-Host "Executing $($command.CommandText)"
                    
                            $result = $command.ExecuteNonQuery()
                            Write-Verbose "ExecuteNonQuery result: $result"
                    
                            Write-Output "Successfully executed the database creation script for $createDatabaseName"
                        }
                    
                        finally {
                            if ($null -ne $sqlConnection) {
                                Write-Output "Closing the connection to $createSqlServer"
                                $sqlConnection.Dispose()
                            }
                        }
                    }
                    EOT
                Octopus.Action.Script.ScriptSource = "Inline"
                Octopus.Action.Script.Syntax = "PowerShell"
                Octopus.ProcessTemplate.Slug = "runbook-create-database-infrastructure"
                Octopus.ProcessTemplate.Version = "1.0.0"
                OctopusUseBundledTooling = "False"
                Template.SQLServer.Database.Name = "#{Standards.Database.Name}"
                Template.SQLServer.Name = "#{KeyVault.SQLServer.Server.Name}"
                Template.SQLServer.User.Name = "#{KeyVault.SQLServer.User.Name}"
                Template.SQLServer.User.Password = "#{KeyVault.SQLServer.User.Password}"
                Template.WorkerPool = "#{Standards.Worker.Pool}"
            }
            worker_pool_variable = "#{Template.WorkerPool}"
        }
    }

    step "create-database-verify-database-creation" {
        name = "Create Database-Verify Database Creation"

        action {
            action_type = "Octopus.Script"
            notes = <<-EOT
                    **Always Runs**
                    
                    Runs a script on the database to make sure it was successfully created.
                    EOT
            properties = {
                Octopus.Action.AutoRetry.MaximumCount = "3"
                Octopus.Action.AutoRetry.MinimumBackoff = "15"
                Octopus.Action.Blueprint.ConsumingAction.Name = "Create Database"
                Octopus.Action.Script.ScriptBody = <<-EOT
                    $scriptToRun = "Select 1 as Number"
                    $databaseName = $OctopusParameters["Template.SQLServer.Database.Name"]
                    $databaseServer = $OctopusParameters["Template.SQLServer.Name"]
                    $userName = $OctopusParameters["Template.SQLServer.User.Name"]
                    $userPassword = $OctopusParameters["Template.SQLServer.User.Password"]
                    
                    Write-Host "Database Server: $databaseServer"
                    Write-Host "Database Name: $databaseName"
                    
                    if ([string]::IsNullOrWhiteSpace($userName) -eq $true){
                    	Write-Host "No username found, using integrated security"
                        $connectionString = "Server=$databaseServer;Database=$databaseName;integrated security=true;"
                    }
                    else {
                    	Write-Host "Username found, using SQL Authentication"
                        $connectionString = "Server=$databaseServer;Database=$databaseName;User ID=$userName;Password=$userPassword;"
                    }
                    
                    $sqlConnection = New-Object System.Data.SqlClient.SqlConnection
                    $sqlConnection.ConnectionString = $connectionString
                    
                    $command = $sqlConnection.CreateCommand()
                    $command.CommandType = [System.Data.CommandType]'Text'
                    $command.CommandText = $scriptToRun
                    
                    Write-Host "Opening the connection to $databaseName on $databaseServer"
                    
                    $sqlConnection.Open()   
                    
                    try
                    {
                    	Write-Highlight "Creating transaction"
                    	$command.Transaction = $sqlConnection.BeginTransaction()
                        
                        Write-Highlight "Running query now"
                    	$rowsChanged = $command.ExecuteNonQuery()
                        
                        Write-Highlight "Committing Transaction"
                        $command.Transaction.Commit()
                    }
                    catch
                    {
                    	Write-Highlight "Exception with running script, rolling back transaction"
                    	$command.Transaction.Rollback()
                    	throw $_
                    }
                    EOT
                Octopus.Action.Script.ScriptSource = "Inline"
                Octopus.Action.Script.Syntax = "PowerShell"
                Octopus.ProcessTemplate.Slug = "runbook-create-database-infrastructure"
                Octopus.ProcessTemplate.Version = "1.0.0"
                OctopusUseBundledTooling = "False"
                Template.SQLServer.Database.Name = "#{Standards.Database.Name}"
                Template.SQLServer.Name = "#{KeyVault.SQLServer.Server.Name}"
                Template.SQLServer.User.Name = "#{KeyVault.SQLServer.User.Name}"
                Template.SQLServer.User.Password = "#{KeyVault.SQLServer.User.Password}"
                Template.WorkerPool = "#{Standards.Worker.Pool}"
            }
            worker_pool_variable = "#{Template.WorkerPool}"
        }
    }

    step "create-k8s-infrastrucure-create-application-namespace" {
        name = "Create K8s Infrastrucure-Create Application Namespace"
        properties = {
            Octopus.Action.TargetRoles = "#{Template.Kubernetes.TargetTags}"
        }

        action {
            action_type = "Octopus.KubernetesRunScript"
            notes = <<-EOT
                    **Always Runs**
                    
                    Applies the manifest file to ensure the namespace exists for this particular tenant.
                    EOT
            properties = {
                Octopus.Action.Blueprint.ConsumingAction.Name = "Create K8s Infrastrucure"
                Octopus.Action.Script.ScriptBody = <<-EOT
                    $namespace = $OctopusParameters["Template.Kubernetes.Namespace.Name"]
                    
                    kubectl create namespace $namespace --dry-run=client -o yaml | kubectl apply -f -
                    EOT
                Octopus.Action.Script.ScriptSource = "Inline"
                Octopus.Action.Script.Syntax = "PowerShell"
                Octopus.ProcessTemplate.Slug = "create-container-infrastructure"
                Octopus.ProcessTemplate.Version = "1.0.1"
                Template.Kubernetes.Namespace.Name = "#{Standards.K8s.Namespace}"
                Template.Kubernetes.TargetTags = "trident-web"
            }
            worker_pool_variable = ""
        }
    }

    step "slack-send-simple-notification" {
        condition = "Always"
        name = "Slack - Send Simple Notification"

        action {
            properties = {
                Octopus.Action.Template.Id = "ActionTemplates-101"
                Octopus.Action.Template.Version = "15"
                ssn_Channel = "#{Notification.Slack.Channel.Name}"
                ssn_Color = "good"
                ssn_HookUrl = "#{KeyVault.Slack.Webhook.Url}"
                ssn_IconUrl = "https://octopus.com/content/resources/favicon.png"
                ssn_Message = "#{Notification.Body.Text}"
                ssn_Title = "#{Notification.RunbookStatus.Subject.Text}"
                ssn_Username = "Octopus Deploy"
            }
            worker_pool_variable = "Standards.Worker.Pool"
        }
    }
}